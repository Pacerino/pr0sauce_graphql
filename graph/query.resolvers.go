package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.61

import (
	"context"
	"fmt"
	"os"

	"github.com/pacerino/pr0sauce_graphql/db"
	"github.com/pacerino/pr0sauce_graphql/graph/model"
)

var dsn = fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=%s",
	os.Getenv("DB_HOST"),
	os.Getenv("DB_USER"),
	os.Getenv("DB_PASS"),
	os.Getenv("DB_DATABASE"),
	os.Getenv("DB_PORT"),
	os.Getenv("DB_SSL"),
)

// Item is the resolver for the item field.
func (r *queryResolver) Item(ctx context.Context, limit *int32, offset *int32, itemID *int32) ([]*model.Item, error) {
	if *limit > 200 {
		return nil, fmt.Errorf("limit must be less than 200")
	}
	dbc, err := db.ConnectDB(dsn)
	if err != nil {
		return nil, err
	}
	var items []*model.Item
	query := dbc.Model(&db.Items{}).Joins("Comment").Order("id DESC").Limit(int(*limit)).Offset(int(*offset))
	if itemID != nil && *itemID > 0 {
		query = query.Where(&db.Items{ItemID: int(*itemID)})
	}
	err = query.Find(&items, "title != ''").Error
	return items, err
}

// Comment is the resolver for the comment field.
func (r *queryResolver) Comment(ctx context.Context, limit *int32, offset *int32, itemID *int32) ([]*model.Comment, error) {
	if *limit > 200 {
		return nil, fmt.Errorf("limit must be less than 200")
	}
	dbc, err := db.ConnectDB(dsn)
	if err != nil {
		return nil, err
	}
	var comments []*model.Comment
	query := dbc.Model(&db.Comments{}).Order("id DESC").Limit(int(*limit)).Offset(int(*offset))
	if itemID != nil && *itemID > 0 {
		query = query.Where(&db.Comments{ItemID: int(*itemID)})
	}
	err = query.Find(&comments).Error
	return comments, err
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
